---
title: "Data Types in R"
subtitle: "BODL R Training"
author: "Dr Stevie Pederson"
institute: "Black Ochre Data Labs<br>Telethon Kids Institute"
date: "2023-02-17"
date-format: long
title-slide-attributes:
    data-background-color: "#3c3c44"
    data-background-image: assets/bodl_logo_white_background.jpg
    data-background-opacity: "0.3"
    data-background-size: "90%"
editor: source
format: 
  revealjs:
    theme: [../custom.scss]
    code-line-numbers: false
    width: 1024
    height: 768
    sansfont: Times New Roman
    logo: assets/bodl_logo_white_background.jpg
---

```{r setup, echo = FALSE, include = FALSE}
if (interactive()) setwd(here::here("docs"))
knitr::opts_chunk$set(
  echo = TRUE, include = TRUE, warning = FALSE, message = FALSE, 
  fig.align = "center", results = 'hide', fig.show = "asis",
  fig.width = 6
)
```

## Welcome To Day 2

Today's Topics:

1. __`R` Objects & Data Types__
2. Text Manipulation
3. Basic Statistical Analysis
4. Writing Functions and Iteration
5. The Bioconductor Project


# `R` Objects {background-color="#3c3c44"}

## Before we start {.build}

1. Clear your `Global Environment`  (![](assets/broom.png))
2. Create a new RMarkdown File:  
    + `File > New File > R Markdown`
    + Save as `DataTypes.Rmd`
3. Add your name, today's date and athe titles "Data Types in R"

## Recap Of Day 1

We learned how to:

1. Load a csv using `readr::read_csv()`
2. Look through & summarise a `data.frame`
3. Pipe data objects (`%>%` or `|>`)
4. Generate plots with `ggplot2`
5. Use Rmarkdown


## `R` Objects

- Main data type so far has been a `data.frame` 
    - `tibble` = `data.frame` with nice wrapping paper
- Each column has the same type of data, e.g. `numeric`, `character` etc.
- The columns can be different types to each other
- In `R` each column is a `vector`

# Vectors {background-color="#3c3c44"}

## Vectors

The key building blocks for `R` objects: **Vectors**

- There is no such thing as a *scalar* in `R`
    + A scalar is a single number
- Everything is based around the concept of a *vector*

**What is a vector?**

. . .

### Definition

A vector is zero or more values of the **same type**

## Examples

A simple vector would be

```{r show-seq, echo=FALSE, include=TRUE, results='markup'}
1:10
```

__What type of values are in this vector?__

## Examples

Another vector might be

```{r show-chars, echo=FALSE, include=TRUE, results='markup'}
c("a", "cat", "video")
```

__What type of values are in this vector?__

## Examples

__What type of values are in this vector?__

```{r show-more-cars, echo=FALSE, include=TRUE, results='markup'}
c("742", "Evergreen", "Tce")
```


## The 4 Atomic Vector Types

- *Atomic Vectors* are the building blocks for everything in `R`
- There are siz atomic vector types
    + Four we'll focus on
    - Two we can ignore
    
. . .

1. _logical_
2. _integer_
3. _numeric_
4. _character_

. . .

(We'll ignore `complex` and `raw` vectors)


## Logical Vectors

1. **logical**: Can only hold the values `TRUE` or `FALSE`

```{r logi-vec}
logi_vec <- c(TRUE, TRUE, FALSE)
print(logi_vec)
```


## Integer Vectors

1. logical
2. **integer**: Counts, ranks or indexing positions 

```{r int-vec}
int_vec <- 1:5
print(int_vec)
```


## Double (i.e. Double Precision) Vectors

1. logical
2. integer
3. **double**: Usually (& *lazily*) referred to as `numeric`

```{r bdl-vec, results='hide'}
dbl_vec <- c(0.618, 1, 2.618)
print(dbl_vec)
```

**Why are these called doubles?**

## Character Vectors

1. logical
2. integer
3. double
4. **character**

```{r char-vec, include=TRUE, results='hide'}
char_vec <- c("blue", "red", "green")
print(char_vec)
```

## The 4 Atomic Vector Types

These are the basic building blocks for all `R` objects

1. logical
2. integer
3. double
4. character

. . .

**All `R` data structures are built on these!**

## Properties of a vector

What *four* defining properties might a vector have?

::: {.incremental}

1. The *values*
2. *Length*
    + Accessed by the function `length()`
3. *Type*
    + Accessed by the function `typeof()`
    + Preferable to `class()` for vectors
4. Any optional & additional *attributes* 
    + Accessed using `attributes()`
    + Holds data such as `names` etc.
    
:::

## Properties of a vector

__Let's try them on our vectors__

```{r try-funs, results='hide'}
typeof(char_vec)
length(int_vec)
attributes(logi_vec)
class(dbl_vec)
typeof(dbl_vec)
```

__Were you surprised by any of the results?__

## Working with Vectors

We can *combine* two vectors in `R`, using the function `c()`

```{r show-c}
c(1, 2)
```

- The numbers `1` & `2` were both vectors with `length()` == 1

- We have combined two vectors of length 1, to make a vector of length 2

. . .

- A vector of length zero is able to be formed using `c()`
    + This also represents the value `NULL` in `R`

## Working with Vectors 

__What would happen if we combined two vectors of different types?__

. . .

Let's try & see what happens:

```{r new-vec, results='hide'}
new_vec <- c(logi_vec, int_vec)
print(new_vec)
typeof(new_vec)
```

. . .

__What happened to the `logical` values?__

. . .

`R` will coerce them into a common type (i.e. integers).

# Coercion {background-color="#3c3c44"}

## Coercion

::: {.incremental}

- If combining values of the same type $\implies$ no coercion
- If combining values of different types
    + `R` will coerce to the simplest possible value
    + ` `1) `logical`, 2) `integer`, 3) `numeric` and 4) `character`
    + These are ranked by memory, i.e. `logical` values occupy a *single byte*
- When no coercion is possible `NA` values will be produced
- We can explicitly coerce values using `as.*()`
    + `as.logical()`, `as.integer()`, `as.numeric()`, `as.character()`
    + `as.*()` functions are also implemented for other data-types

:::


## Discussion Questions

::: {.incremental}

1. **What other types could `logical` vectors be coerced into?**
    + Try coercing `logi_vec` to the three other types
2. **Can `numeric` vectors be coerced into `logical` vectors?**
    + Let's try coercing `dbl_vec` to `logical`
3. **Can `numeric` vectors be coerced to `integer` vectors?**
    + Is this what you expected?
    + Anything after the decimal point is simply dropped
3. **Can `character` vectors be coerced into `numeric` vectors?**

:::

. . . 

```{r simp-vec}
simp_vec <- c("742", "Evergreen", "Terrace")
as.numeric(simp_vec)
```

## `NA` and Special Values

::: {.incremental}

- When coercing to more complex types $\implies$ almost never `NA`
- When coercing to simpler data types $\implies$ `NA` values are common
- `NA` values are typed in `R`
    + Type `NA_` in the Console and see what options are shown
    + Can cause problems with code if unexpected
- `NaN` is very different to `NA`
    + This means *Not-a-Number* (e.g. `0/0`)
- `Inf` is a `numeric` value
- `NULL` is an empty value with type `NULL`
    
:::

# Subsetting Vectors {background-color="#3c3c44"}

## Subsetting Vectors

#### Single Brackets

One or more elements of a vector can be called using `[]`

```{r single-brackets}
new_vec
new_vec[2]
new_vec[1:3]
```

This returns an object of the **exact same type**, but with only the elements specified
<br><br>

:::: {.fragment}

#### Double Brackets

Double brackets (`[[]]`) can **only** be used to return __single elements__

```{r double-brackets}
new_vec[[2]]
```

::: {.incremental}

- If you try `new_vec[[1:3]]` you'll receive an error message
- Only a vector of length `1` can be placed here

:::

::::

## Subsetting Vectors

If a vector has name attributes, we can call values by name

- The inbuilt vector `euro` contains conversion rates at the time of Euro launch

```{r eruo-single-brackets}
head(euro)
attributes(euro)
names(euro)
euro["ESP"]
```

## Subsetting Vectors

*Try repeating the* call-by-name *approach using double brackets*

```{r euro-double-brackets}
euro["ESP"]
euro[["ESP"]]
```
<br>

. . .

__What was the difference in the output?__

1. Using `[]` returned a subset of the vector with all other `attributes`
2. Using `[[]]` removed the vector-level `attributes` & just gave the value

## Extracting Multiple Values 

**What is really happening in this line?**

```{r euro-by-position}
euro[1:3]
```

. . .

- `1:3` is an `integer` vector
- We are using an `integer` vector to call values by position

## Discussion Questions

__Would it better to call values by position, or by name?__

Things to consider:

- Which is easier to type "on the fly"?
- Which is easier to read?
- Which is more robust to undocumented changes in an object?


## Extracting Multiple Values 

We can actually define the vectors we use to subset values

```{r euro-by-int-vec}
int_vec
euro[int_vec]
```

. . .

- This can make code harder to read
- Extremely useful when regularly calling values by name

## Vector Operations

`R` Functions are designed to work on vectors

```{r dbl-vec-logical-test, results='hide'}
dbl_vec > 1
```

This is one of the real strengths of `R`

## Vector Operations

We can also combine the above logical test and subsetting

```{r subset-dbl-vec-by-logical}
dbl_vec
dbl_vec > 1
dbl_vec[dbl_vec > 1]
```

. . .

- Here we've used a logical vector to extract values 
    + Must be the same length as the main vector
    + Usually used to self-subset

## Vector Operations

An additional logical test: `%in%` (read as: "*is in*")

```{r print-dbl-int-vecs}
dbl_vec
int_vec
```

We can use this to check of values from one vector are in another

. . .

```{r dbl-is-in-int, results='hide'}
dbl_vec %in% int_vec
```

. . .

Returns `TRUE/FALSE` for each value in `dbl_vec` if it **is in** `int_vec`

NB: `int_vec` was coerced silently to a `double` vector

. . .

```{r subset-dbl-by-is-in-int}
dbl_vec[dbl_vec %in% int_vec]
```

## Vectors

Any questions...?

# Matrices {background-color="#3c3c44"}

## Matrices

- Vectors are strictly one dimensional and have a `length` attribute.
- A `matrix` is the **two dimensional** equivalent

```{r, results='hide'}
int_mat <- matrix(1:6, ncol=2)
int_mat
```

## Matrices

- Matrices can only hold __one__ type of value
    + i.e. logical, integer, double, character
- Have additional attributes such as `dim()`, `nrow()` `ncol()`
- Can have __optional__ `rownames()` & `colnames()`

## Matrices

__Some commands to try:__

```{r, results='hide'}
dim(int_mat)
typeof(int_mat)
class(int_mat)
attributes(int_mat)
colnames(int_mat)
length(int_mat)
```

__Ask questions if anything is confusing__

## Matrices

- Use square brackets to extract values by row & column
- The form is `x[row, col]`
- Leaving either `row` or `col` blank selects the entire row/column

```{r, results='hide'}
int_mat[2, 2]
int_mat[1,]
```

__How would we just get the first column?__

## Matrices

__NB: Forgetting the comma when subsetting will treat the matrix as a single vector running down the columns__

```{r}
int_mat
int_mat[5]
```

## Matrices

**Requesting a row or column that doesn't exist is the source of a very common error message**

```{r}
dim(int_mat)
```

```{r, eval=FALSE}
int_mat[5,]
```
<div class="red">
```
Error in int_mat[5, ] : subscript out of bounds
```
</div>


## Arrays

Arrays extend matrices to 3 or more dimensions

Beyond the scope of today, but we just have more commas in the square brackets, e.g.
```{r}
dim(iris3)
length(iris3)
```

```{r,eval=FALSE}
dimnames(iris3)
```

## Arrays

```{r}
iris3[1,,]
```
```{r,results='hide'}
iris3[1:2,,]
```

## Summary | Homogeneous Data Types

- Vectors, Matrices & Arrays are the basic *homogeneous* data types of `R`
- All are essentially just vectors

# Heterogeneous Data Types

## Heterogeneous Data Types

Summary of main data types in `R`

Dimension   | Homogeneous | Heterogeneous
------------|-------------|--------------
1d          | `vector`    | `list`
2d          | `matrix`    | `data.frame`
3d+         | `array`     |

## Lists

A `list` is a __heterogeneous__ vector.

- Each component is an `R` object
- Can be a `vector`, or `matrix`
- Could be another `list`
- Any other `R` object type we haven't seen yet

**These are incredibly common in `R`**

## Lists

Many `R` functions provide output as a list

```{r, results='hide'}
testResults <- t.test(dbl_vec)
class(testResults)
typeof(testResults)
testResults
```

NB: There is a function (`print.htest()`) that tells `R` how to print the results to the Console

## Lists

Explore the various attributes of the object `testResults`

```{r, results='hide'}
str(testResults)
attributes(testResults)
length(testResults)
```


## Lists

We can call the individual components of a list using the `$` symbol followed by the name

```{r, results='hide'}
testResults$statistic
testResults$conf.int
testResults$method
```

*Note that each component is quite different to the others.*

## Subsetting Lists

A `list` is a `vector` so we can also subset using the `[]` method

```{r, results='hide'}
testResults[1]
typeof(testResults[1])
```

- Using single square brackets returns a `list` 
    - i.e. an object which is a subset of the larger object, but of the *same type*

## Subsetting Lists

Double brackets again retrieve a single element of the vector

- Returns the actual component as the underlying `R` object

```{r, results='hide'}
testResults[[1]]
typeof(testResults[[1]])
```

*When would we use either method?*

## Subsetting Lists

We can also use names instead of positions

```{r, results='hide'}
testResults[c("statistic", "p.value")]
testResults[["statistic"]]
```


## Lists

- Note also the **Environment** Tab in the top right of RStudio
- Click the arrow next to `testResults` to expand the entry
- This is the output of `str(testResults)`

# Data Frames

## Data Frames

Finally!

- These are the *most common type of data* you will work with
- Each column is a `vector`
- Columns can be a different type of vector
- Column vectors **MUST** be the same length


## Data Frames

- Analogous to matrices, but are **specifically for heterogeneous data**
- Have many of the same attributes as matrices
    + `dim()`, `nrow()`, `ncol()`, `rownames()`, `colnames()`
- `colnames()` & `rownames()` are **NOT** optional & are assigned by default

## Data Frames

Let's load `toothData` again

```{r, eval=TRUE, results='hide'}
library(tidyverse)
toothData <- read_csv("data/toothData.csv")
```

__Try these commands__

```{r, results='hide'}
glimpse(toothData)
colnames(toothData)
dim(toothData)
nrow(toothData)
```

## Data Frames

Individual entries can also be extracted using the square brackets

```{r, results='hide'}
toothData[1:2, 1]
```

We can also refer to columns by name (same as matrices)

```{r, results='hide'}
toothData[1:2, "len"]
```

## Data Frames

The `dplyr` (i.e. `tidy`) way of doing this would be:

```{r}
toothData %>%
  slice(1:2) %>%
  select(len)
```


## Data Frames

Remember that each column is a separate vector

- We can call each column vector of a `data.frame` using the `$` operator

```{r, results='hide'}
toothData$len[1:2]
```

**This does NOT work for rows!!!**

## Data Frames

- `R` is *column major* by default (as is `FORTRAN` & Matlab)
- Many other languages are *row major*, e.g. C/C++, Python
- `R` was designed for statistical analysis, but has developed capabilities **far beyond this**

(We will see this advantage this afternoon)

# Data Frames & Lists

## Data Frames & Lists

__Data frames are actually special cases of lists__

- Each column of a `data.frame` is a component of a `list`
- The components must all be vectors of the **same length**
- Data Frames can be treated identically to a `list`
- Have additional subsetting operations and attributes

## Data Frames & Lists

Forgetting the comma, now gives a completely different result to a matrix!

```{r, eval=FALSE}
toothData[1]
```

__Was that what you expected?__

__Try using the double bracket method__

## Data Frames & Lists | More Errors

**What do you think will happen if we type:**

```{r, eval=FALSE}
toothData[5]
```

## Data Frames & Lists | More Errors

**What do you think will happen if we type:**

```{r, eval=FALSE}
toothData[5]
```

<div class="red">
Error: Column index must be at most 3 if positive, not 5
</div>


# Working With `R` Objects

## Vectors | Name Attributes

__How do we assign names?__

```{r}
named_vec <- c(a = 1, b = 2, c = 3)
```

OR we can name an existing vector

```{r}
names(int_vec) <- c("a", "b", "c", "d", "e")
```

## Vectors | Name Attributes

__Can we remove names?__

The `NULL`, or empty, vector in `R` is created using `c()`

```{r, results='hide'}
null_vec <- c()
length(null_vec)
```

## Vectors | Name Attributes

We can use this to remove names

```{r}
names(named_vec) <- c()
```

*Don't forget to put the names back...*

## Matrices

We can convert vectors to matrices, as earlier

```{r}
int_mat <- matrix(1:6, ncol=2)
```

`R` is column major so fills columns by default

```{r}
row_mat <- matrix(1:6, ncol=2, byrow =TRUE)
```

## Matrices 

We can assign row names & column names after creation

```{r}
colnames(row_mat) <- c("odds", "evens")
```

Or using `dimnames()`

```{r, results='hide'}
dimnames(row_mat)
```

This a list of `length` 2 with `rownames` then `colnames` as the components.

**Why were the elements not named `rownames` or `colnames`?**

<!-- ## Matrices | A word of caution -->

<!-- ```{r, warning=FALSE} -->
<!-- rec_mat <- matrix(int_vec, ncol = 2) -->
<!-- ``` -->

<!-- __Did we successfully form an `R` object?__ -->

<!-- __What has happened here?__ -->

<!-- __This is a major (and warranted) criticism made of R__ -->

## Lists

```{r}
my_list <- list(int_vec, dbl_vec)
names(my_list) <- c("integers", "doubles")
```
OR

```{r}
my_list <- list(integers = int_vec, doubles = dbl_vec)
```

## Lists

__What happens if we try this?__

```{r}
my_list$logical <- logi_vec
```

<!-- ## Lists -->
<!-- We can coerce vectors to lists as well -->
<!-- ```{r} -->
<!-- int_list <- as.list(named_vec) -->
<!-- ``` -->

## Data Frames

This is exactly the same as creating lists, but

__The `names` attribute will also be the `colnames()`__

```{r}
my_df <- data.frame(doubles = dbl_vec, logical = logi_vec)
names(my_df) == colnames(my_df)
```

## Data Frames

__What happens if we try to add components that aren't the same length?__

```{r, eval=FALSE}
my_df <- data.frame(integers = int_vec, 
                    doubles = dbl_vec,
                    logical = logi_vec)
```


# Morning Tea


<div class="footer" style="text-align:center;width:25%">
[Home](http://uofabioinformaticshub.github.io/RAdelaide-July-2018/)
</div>
